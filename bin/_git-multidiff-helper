#!/usr/bin/env python

import errno
import os
import shutil
import stat
import sys

"""
Helper used by git-multidiff.

This script is used as the "difftool" when invoking git-difftool. It
creates copies of (or hardlinks to) files that appear to be temporary,
and records the names of the files that git-multidiff will need to diff.
"""

# I can't believe this isn't already in shutil.
def mkdirp(dir):
  """
  Python version of 'mkdir -p'.

  Creates directory, including parent directories. Doesn't get upset if
  directory already exists.
  """
  try:
    os.makedirs(dir)
  except OSError as e:
    if e.errno != errno.EEXIST:
      raise

def looks_like_a_temp_file(fnam):
  """
  Returns True iff the file appears to be a git-difftool temporary file.
  """
  return (
    # temp files are all absolute
    os.path.isabs(fnam)
    # /dev/null is probably the only non-regular file we'll ever see, but
    # lets assume all special files are permanent.
    and stat.S_ISREG(os.stat(fnam).st_mode))

def main(argv):
  DEBUG = False
  # TODO: find some way to pass fatal errors up to top-level?
  tmpdir = os.environ['GIT_MULTIDIFF_TEMP']
  out = open(os.path.join(tmpdir, 'args'), 'a')
  for fnam in argv[1:]:
    if looks_like_a_temp_file(fnam):
      # A leading double-slash has system defined meaning in POSIX so
      # treat such files as different from others just in case.
      root = 'dslash' if fnam.startswith('//') else 'slash'

      # The '' here adds the path separator at the end.
      dest = os.path.join(tmpdir, root, '')

      # XXX Use + instead of os.join because os.join would ignore the
      # left arg if the right arg is absolute. Unfortunately, doing this
      # may not be entirely portable, especially if the file system
      # doesn't like seeing multiple path separators in a row.
      dest += fnam

      mkdirp(os.path.dirname(dest))
      try:
        os.link(fnam, dest)
        if DEBUG: print 'ln %r -> %r' % (fnam, dest)
      except OSError:
        # TODO: this doesn't work with multiple occurrences of the same
        # file (in particular, /dev/null) as we make the destination
        # read-only. This should get fixed once the perm stuff is moved.
        shutil.copy2(fnam, dest)
        if DEBUG: print 'cp %r -> %r' % (fnam, dest)
        try:
          # Make copy read-only
          perms = os.stat(dest).st_mode \
              & ~(stat.S_IWGRP | stat.S_IWOTH | stat.S_IWUSR)
          os.chmod(dest, perms)
          if DEBUG: print 'chmod a-r %r' % dest
        except IOError:
          pass # we tried, but it isn't critical that we succeed
    else:
      dest = fnam
    out.write(dest)
    out.write('\0')
  out.close()

if __name__ == '__main__':
  main(sys.argv)
