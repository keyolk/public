#!/usr/bin/env python

import errno
import os
import shutil
import stat
import sys

"""
Helper used by git-multidiff.

This script is used as the "difftool" when invoking git-difftool. It
creates copies of (or hardlinks to) files that appear to be temporary,
and records the names of the files that git-multidiff will need to diff.
"""

# I can't believe this isn't already in shutil.
def mkdirp(dir):
  """
  Python version of 'mkdir -p'.

  Creates directory, including parent directories. Doesn't get upset if
  directory already exists.
  """
  try:
    os.makedirs(dir)
  except OSError as e:
    if e.errno != errno.EEXIST:
      raise

def main(argv):
  DEBUG = False
  # TODO: find some way to pass fatal errors up to top-level?
  tmpdir = os.environ['GIT_MULTIDIFF_TEMP']
  out = open(os.path.join(tmpdir, 'args'), 'a')
  for fnam in argv[1:]:
    # TODO: treat files in /dev/ like files in workspace?
    if os.path.isabs(fnam):
      if fnam.startswith('//'):
        # A leading double-slash has system defined meaning in POSIX so
        # treat such files as different from others just in case.
        dest = os.path.join(tmpdir, 'dslash')
      else:
        dest = os.path.join(tmpdir, 'slash')
      dest += fnam
      mkdirp(os.path.dirname(dest))
      try:
        os.link(fnam, dest)
        if DEBUG: print 'ln %r -> %r' % (fnam, dest)
      except OSError:
        # TODO: this doesn't work with multiple occurrences of the same
        # file (in particular, /dev/null) as we make the destination
        # read-only. This should get fixed once the perm stuff is moved.
        shutil.copy2(fnam, dest)
        if DEBUG: print 'cp %r -> %r' % (fnam, dest)
        try:
          # Make copy read-only
          perms = os.stat(dest).st_mode \
              & ~(stat.S_IWGRP | stat.S_IWOTH | stat.S_IWUSR)
          os.chmod(dest, perms)
          if DEBUG: print 'chmod a-r %r' % dest
        except IOError:
          pass # we tried, but it isn't critical that we succeed
    else:
      dest = fnam
    out.write(dest)
    out.write('\0')
  out.close()

if __name__ == '__main__':
  main(sys.argv)
